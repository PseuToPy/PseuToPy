/**
 * This grammar is taken from the grammar definition of Python 3.8.2, available
 * here: https://docs.python.org/3/reference/grammar.html
 *
 * Some changes were made at very specific points in order to adapt this
 * grammar to the pseudocode grammar we wish to create.
 *
 * A side-effect of this approach is that instructions written in Python 3.8
 * will be accepted as valid pseudocode instructions.
 */


Module: statements*=Stmt;
Stmt: (SimpleStmt | CompoundStmt);
SimpleStmt: SmallStmt (';' SmallStmt)* (';')?;
SmallStmt: (PrintStmt | InputStmt | FuncCallStmt | ExprStmt | DelStmt | 
    PassStmt | FlowStmt | ImportStmt | GlobalStmt | NonLocalStmt | AssertStmt)
;

PrintStmt: ('print' | 'display' | 'show') 
    '('? (args=TestList ((',' | 'followed by') args=TestList)*) ')'?;
InputStmt: 'input' ('number' | 'integer')? '('?
    (args=Atom (',' TestList)?) ')'?;
FuncCallStmt: 'call function' name=Name 
    ('with' /parameter(s)?/ '('? (args=TestList (',' args=TestList)?) ')'?)?;

ExprStmt: 
    Assign | 
    TestListStarExpr (
        AnnAssign | AugAssign (YieldExpr | TestList) | 
       (('=' (YieldExpr | TestListStarExpr))+)?)
;
AnnAssign: ':' Test ('=' (value=YieldExpr | value=TestListStarExpr))?;
TestListStarExpr: (Test | StarExpr) (',' (Test | StarExpr))* (',')?;
AugAssign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | 
    '<<=' | '>>=' | '**==' | '//=')
;
Assign: AssignStmt | DeclareStmt;
AssignStmt : 'set' (name=Name (',' Name)*) 'to' 
    (('the result of' (value=InputStmt | value=FuncCallStmt)) | 
    (value=TestList (',' TestList)*)
);
DeclareStmt: 'declare' (name=Name (',' Name)*);

DelStmt: 'del' ExprList;
PassStmt: 'pass';
FlowStmt: BreakStmt | ContinueStmt | ReturnStmt | RaiseStmt | YieldStmt;
BreakStmt: 'break';
ContinueStmt: 'continue';
ReturnStmt: 'return' value=TestListStarExpr?;
YieldStmt: YieldExpr;
RaiseStmt: 'raise' (Test ('from' Test)?)?;
ImportStmt: ImportName | ImportFrom;
ImportName: 'import' DottedAsNames;
ImportFrom: ('from' (('.' | '...')* DottedName | ('.' | '...')+)
                'import' ('*' | '(' ImportAsNames ')' | ImportAsNames)
);
ImportAsName: Name ('as' Name)?;
DottedAsName: DottedName ('as' Name)?;
ImportAsNames: ImportAsName (',' ImportAsName)? ','?;
DottedAsNames: DottedAsName (',' DottedAsName)?;
DottedName: Name ('.' Name)*;
GlobalStmt: 'declare global' Name (',' Name)*;
NonLocalStmt: 'declare non local' Name (',' Name)*;
AssertStmt: 'assert' Test (',' Test)?;

CompoundStmt: IfStmt | WhileStmt | ForStmt | TryStmt | WithStmt | FuncDef |
    ClassDef | Decorated | AsyncStmt;
Decorator: '@' DottedName ('(' ArgList? ')')?;
Decorators: Decorator+;
Decorated: Decorators (ClassDef | FuncDef | AsyncFuncDef);

AsyncFuncDef: 'ASYNC' FuncDef;
FuncDef: ('define function' | 'def') name=Name 'with'? 
    ('no parameter' | params=Parameters /as parameter(s)?/?)
    /:|to do((\s)*:)?/ ('->' Test)? body=FuncBodySuite 'end';
Parameters: '('? value=TypedArgsList? ')'?;

TypedArgsList: (
    (TfpDef ('=' Test)? (','  TfpDef ('=' Test)?)* ','  '/' 
        (','(TfpDef ('=' Test)? (',' TfpDef ('=' Test)?)*
            ((','  ('*' (TfpDef)? (','  TfpDef ('=' Test)?)* 
            ((','  ('**' TfpDef (',')?)?)?) | '**' TfpDef (',')?))) | 
            '*' (TfpDef)? (','  TfpDef ('=' Test)?)* ((','  ('**' TfpDef (',')?)?)?) |
            '**' TfpDef (',')?)?)?)? |  
    (TfpDef ('=' Test)? (',' TfpDef ('=' Test)?)* 
        ((','  ('*' (TfpDef)? (','  TfpDef ('=' Test)?)* 
        ((','  ('**' TfpDef (',')?))?) |
        '**' TfpDef (',')?)?)?) | 
        '*' (TfpDef)? (','  TfpDef ('=' Test)?)* ((','  ('**' TfpDef (',')?)?)?) |
        '**' TfpDef (',')?)
);

TfpDef: Name (':' Test)?;


AsyncStmt: 'ASYNC' (FuncDef | WithStmt | ForStmt);
IfStmt: 'if' condition=NamedExprTest /:|then((\s)*:)?/ body=Suite 
    (('elif' | 'else if') condition=NamedExprTest /:|then((\s)*:)?/ body=Suite)*
    ('else' /:|then((\s)*:)?/ body=Suite)?
    'end'
;
WhileStmt: 'while' condition=NamedExprTest /:|do((\s)*:)?/ body=Suite 
    ('else' /:|do((\s)*:)?/ body=Suite)?
    'end'
;
ForStmt: 'for' target=ExprList 'in' iterable=TestList /:|do((\s)*:)?/ 
    body=Suite 
    ('else' /:|do((\s)*:)?/ body=Suite)?
    'end'
;
TryStmt: ('try' ':' Suite ((ExceptClause ':' Suite)+
            ('else' ':' Suite)?
            ('finally' ':' Suite) ? |
            'finally' ':' Suite)
);
WithStmt: 'with' WithItem (',' WithItem)* ':' Suite;
WithItem: Test ('as' Expr)?;
ExceptClause: 'except' (Test ('as' Name)?)?;
Suite: (SimpleStmt | Stmt)+;

NamedExprTest: Test (':=' Test)?;

Test: OrTest ('if' OrTest 'else' OrTest)*;
TestNoCond: OrTest;
OrTest: left=AndTest (('or' | '||') right=AndTest)*;
AndTest: left=NotTest (('and' | '&&') right=NotTest)*;
NotTest: 'not' value=NotTest | value=Comparison;
Comparison: left=Expr (operator=CompOp right=Expr)*;
CompOp: '<' | 'is lower than' | '>' | 'is greater than' | 
    '==' | 'is equal to' | '!=' | 'is different from' | 'is not equal to' |
    '>=' | 'is greater or equal to' | '<=' | 'is lower or equal to' |
    'in' | 'not in' | 'is' | 'is not';
StarExpr: '*' Expr;
Expr: left=XorExpr ('|' right=XorExpr)*;
XorExpr: left=AndExpr ('^' right=AndExpr)*;
AndExpr: left=ShiftExpr ('&' right=ShiftExpr)*;
ShiftExpr: left=ArithExpr (('<<' | '>>') right=ArithExpr)*;
ArithExpr: left=Term (('+' | 'plus' | '-' | 'minus') right=Term)*;
Term: left=Factor (('*' | 'times' | '@' | '/' | 'divided by' | '%' | 'modulo' | 
    '//') right=Factor)*;
Factor: ('+' | '-' | '~') value=Factor | value=Power;
Power: base=AtomExpr ('**' exponent=Factor)?;
AtomExpr: 'AWAIT'? Atom Trailer*;
Atom: ('(' (YieldExpr | TestListComp)? ')' |
    '[' TestListComp? ']' |
    '{' DictOrSetMaker '}' |
    Name | Number | String+ | '...' | 'None' | Boolean
);
TestListComp: (NamedExprTest | StarExpr) 
    (CompFor | (',' (NamedExprTest | StarExpr))* (',')?);
Trailer: '(' ArgList? ')' | '[' SubscriptList ']' | '.' Name;
SubscriptList: Subscript (',' Subscript)* ','?;
Subscript: Test | Test? ':' Test? SliceOp?;
SliceOp: ':' Test?;
ExprList: (Expr | StarExpr) (',' (Expr | StarExpr))* ','?;
TestList: 'range' '(' params=RangeParams ')' |
    iterable+=Test[eolterm];
RangeParams: args=Term ((',' args=Term)?)?;
DictOrSetMaker: ( ((Test ':' Test | '**' Expr)
                    (CompFor | (',' (Test ':' Test | '**' Expr))* (',')?)) |
                    ((Test | StarExpr)
                     (CompFor | (',' (Test | StarExpr))* (',')?))
);

ClassDef: 'class' Name ('(' ArgList? ')')? ':' Suite;

ArgList: Argument (',' Argument)* ','?;
Argument: ( Test CompFor? |
            Test ':=' Test |
            Test '=' Test |
            '**' Test |
            '*' Test
);
CompIter: CompFor | CompIf;
SyncCompFor: 'for' ExprList 'in' OrTest CompIter?;
CompFor: 'ASYNC'? SyncCompFor;
CompIf: 'if' TestNoCond CompIter?;

YieldExpr: 'yield' YieldArg?;
YieldArg: 'from' Test | TestListStarExpr;

FuncBodySuite: (SimpleStmt | Stmt)+;

Keyword: 'input' | 'number' | 'integer';
SafeId: !Keyword ID;
Name: id=SafeId;
String: value=STRING;
Number: value=NUMBER;
Boolean: value=BOOL;
