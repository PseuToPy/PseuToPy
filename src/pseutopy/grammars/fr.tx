/**
 * This grammar is taken from the grammar definition of Python 3.8.2, available
 * here: https://docs.python.org/3/reference/grammar.html
 *
 * Some changes were made at very specific points in order to adapt this
 * grammar to the pseudocode grammar we wish to create.
 *
 * A side-effect of this approach is that instructions written in Python 3.8
 * will be accepted as valid pseudocode instructions.
 */


Module: statements*=Stmt;
Stmt: (SimpleStmt | CompoundStmt);
SimpleStmt: SmallStmt (';' SmallStmt)* (';')?;
SmallStmt: (PrintStmt | InputStmt | FuncCallStmt | DeclareStmt | ExprStmt |
    DelStmt | PassStmt | FlowStmt | ImportStmt | GlobalStmt | NonLocalStmt |
    AssertStmt)
;

PrintStmt: ('afficher' | 'montrer')
    '('? (args=TestList ((',' | 'followed by') args=TestList)*) ')'?;
InputStmt: 'donnée' (cast_type='nombre' | cast_type='entier')? '('?
    (args=Atom (',' values=TestList)*) ')'?;
FuncCallStmt: 'appeler la fonction' name=Name
    ('avec' /comme paramètre(s)?/ '('? (args=TestList (',' args=TestList)?) ')'?)?;

ExprStmt: ('mettre' '('?)? name=TestListStarExpr
    (AnnAssign | 
    AugAssign (YieldExpr | TestList) |
    ((('à' | '=') (chained_value=YieldExpr | chained_value=TestListStarExpr))+)? |
    ('au résultat de la fonction:' (value=InputStmt | value=TestList | value=FuncCallStmt)))
;

AnnAssign: ':' Test ('=' (value=YieldExpr | value=TestListStarExpr))?;
TestListStarExpr: (values=Test | values=StarExpr) 
    (',' (values=Test | values=StarExpr))* (',')?
;
AugAssign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | 
    '<<=' | '>>=' | '**==' | '//=')
;
DeclareStmt: 'déclarer' name=Name;

DelStmt: 'del' name=ExprList;
PassStmt: 'passer';
FlowStmt: BreakStmt | ContinueStmt | ReturnStmt | RaiseStmt | YieldStmt;
BreakStmt: 'casser';
ContinueStmt: 'continuer';
ReturnStmt: 'retourner' value=TestListStarExpr?;
YieldStmt: YieldExpr;
RaiseStmt: 'raise' (Test ('from' Test)?)?;
ImportStmt: ImportName | ImportFrom;
ImportName: 'importer' DottedAsNames;
ImportFrom: ('pour' (('.' | '...')* DottedName | ('.' | '...')+)
                'importer' ('*' | '(' ImportAsNames ')' | ImportAsNames)
);
ImportAsName: Name ('as' Name)?;
DottedAsName: DottedName ('as' Name)?;
ImportAsNames: ImportAsName (',' ImportAsName)? ','?;
DottedAsNames: DottedAsName (',' DottedAsName)?;
DottedName: Name ('.' Name)*;
GlobalStmt: 'declare global' Name (',' Name)*;
NonLocalStmt: 'declare non local' Name (',' Name)*;
AssertStmt: 'assert' Test (',' Test)?;

CompoundStmt: IfStmt | WhileStmt | ForStmt | TryStmt | WithStmt | FuncDef |
    ClassDef | Decorated | AsyncStmt;
Decorator: '@' DottedName ('(' ArgList? ')')?;
Decorators: Decorator+;
Decorated: Decorators (ClassDef | FuncDef | AsyncFuncDef);

AsyncFuncDef: 'ASYNC' FuncDef;
FuncDef: ('définir la fonction' | 'def') name=Name 'avec'?
    ('aucun paramètre' | params=Parameters /comme paramètre(s)?/?)
    /:|to do((\s)*:)?/ ('->' test=Test)? body=FuncBodySuite 'fin';
Parameters: '('? value=TypedArgsList? ')'?;

TypedArgsList: (
    (type_def=TfpDef ('=' value=Test)? (','  type_def=TfpDef ('=' value=Test)?)* ','  '/' 
        (','(type_def=TfpDef ('=' value=Test)? (',' type_def=TfpDef ('=' value=Test)?)*
            ((','  ('*' (type_def=TfpDef)? (','  type_def=TfpDef ('=' value=Test)?)* 
            ((','  ('**' type_def=TfpDef (',')?)?)?) | '**' type_def=TfpDef (',')?))) | 
            '*' (type_def=TfpDef)? (','  type_def=TfpDef ('=' value=Test)?)* ((','
            ('**' type_def=TfpDef (',')?)?)?) |
            '**' type_def=TfpDef (',')?)?)?)? |  
    (type_def=TfpDef ('=' value=Test)? (',' type_def=TfpDef ('=' value=Test)?)* 
        ((','  ('*' (type_def=TfpDef)? (','  type_def=TfpDef ('=' value=Test)?)* 
        ((','  ('**' type_def=TfpDef (',')?))?) |
        '**' type_def=TfpDef (',')?)?)?) | 
        '*' (type_def=TfpDef)? (','  type_def=TfpDef ('=' value=Test)?)* ((','  ('**'
        type_def=TfpDef (',')?)?)?) |
        '**' type_def=TfpDef (',')?)
);

TfpDef: name=Name (':' value=Test)?;


AsyncStmt: 'ASYNC' (FuncDef | WithStmt | ForStmt);
IfStmt: 'si' condition=NamedExprTest /:|alors((\s)*:)?/ body=Suite
    (('sinon' | 'else if') condition=NamedExprTest /:|alors((\s)*:)?/ body=Suite)*
    ('else' /:|then((\s)*:)?/ body=Suite)?
    'fin'
;
WhileStmt: 'tant que' condition=NamedExprTest /:|faire((\s)*:)?/ body=Suite
    ('else' /:|do((\s)*:)?/ else_body=Suite)?
    'fin'
;
ForStmt: 'pour' target=ExprList 'dans' iterable=TestList /:|faire((\s)*:)?/ body=Suite
    ('else' /:|do((\s)*:)?/ else_body=Suite)?
    'fin'
;
TryStmt: ('try' ':' Suite ((ExceptClause ':' Suite)+
            ('else' ':' Suite)?
            ('finally' ':' Suite) ? |
            'finally' ':' Suite)
);
WithStmt: 'with' WithItem (',' WithItem)* ':' Suite;
WithItem: Test ('as' Expr)?;
ExceptClause: 'except' (Test ('as' Name)?)?;
Suite: (statement=SimpleStmt | statement=Stmt)+;

NamedExprTest: Test (':=' Test)?;

Test: OrTest ('if' OrTest 'else' OrTest)*;
TestNoCond: OrTest;
OrTest: left=AndTest ((operator='ou' | operator='||') right=AndTest)*;
AndTest: left=NotTest ((operator='et' | operator='&&') right=NotTest)*;
NotTest: operator='non' value=NotTest | value=Comparison;
Comparison: left=Expr (operator=CompOp right=Expr)*;
CompOp: '>=' | 'est supérieur ou égal à' | '<=' | 'est inférieur ou égal à' |
    '<' | 'est inférieur à' | '>' | 'est supérieur à' |
    '==' | 'est égal à' | '!=' | 'est différent de' | "n'est pas égal à" |
    /\bin\b/ | 'dans' | 'pas dans' | 'est' | "n'est pas" | /\bis\b/ ;
StarExpr: '*' Expr;
Expr: left=XorExpr (operator='|' right=XorExpr)*;
XorExpr: left=AndExpr (operator='^' right=AndExpr)*;
AndExpr: left=ShiftExpr (operator='&' right=ShiftExpr)*;
ShiftExpr: left=ArithExpr ((operator='<<' | operator='>>') right=ArithExpr)*;
ArithExpr: left=Term ((operator='+' | operator='plus' |
    operator='-' | operator='moins') right=Term)*;
Term: left=Factor ((operator='*' | operator='fois' | operator='@' |
    operator='/' | operator='divisé par' | operator='%' | operator='modulo' |
    operator='//') right=Factor)*;
Factor: (operator='+' | operator='-' | operator='~' | operator='plus' |
    operator='moins')
    value=Factor | value=Power;
Power: left=AtomExpr ((operator='**' | operator='à la puissance')
    right=Factor)?;
AtomExpr: 'AWAIT'? atom=Atom trailer=Trailer*;
Atom: (is_tuple='(' (values=YieldExpr | values=TestListComp)? ')' |
    is_list='[' values=TestListComp? ']' |
    is_dict='{' values=DictOrSetMaker? '}' |
    name=Name | number=Number | string=String+ | '...' | none=NoneType |
    boolean=Boolean
);
TestListComp: (values=NamedExprTest | values=StarExpr)
    (values=CompFor | (',' (values=NamedExprTest | values=StarExpr))* (',')?);
Trailer: '(' tuple_values=ArgList? ')' | '[' list_values=SubscriptList ']' |
    '.' Name;

SubscriptList: Subscript (',' Subscript)* ','?;
Subscript: Test | Test? ':' Test? SliceOp?;
SliceOp: ':' Test?;
ExprList: (value=Expr | value=StarExpr) (',' (value=Expr | value=StarExpr))* ','?;
TestList: ('la gamme' '(' range_params=RangeParams ')') | args+=Test[eolterm];
RangeParams: args=Expr ((',' args=Expr)*)?;
DictOrSetMaker: (
    ((keys=Test ':' values=Test | '**' values=Expr) 
        (values=CompFor | (',' (keys=Test ':' values=Test | '**' values=Expr))*)(',')?) |
    ((values=Test | values=StarExpr) (values=CompFor | (',' (values=Test |
    values=StarExpr))* (',')?))
);

ClassDef: 'class' Name ('(' ArgList? ')')? ':' Suite;

ArgList: Argument (',' Argument)* ','?;
Argument: ( Test CompFor? |
            Test ':=' Test |
            Test '=' Test |
            '**' Test |
            '*' Test
);
CompIter: CompFor | CompIf;
SyncCompFor: 'for' ExprList 'in' OrTest CompIter?;
CompFor: 'ASYNC'? SyncCompFor;
CompIf: 'if' TestNoCond CompIter?;

YieldExpr: 'yield' YieldArg?;
YieldArg: 'from' Test | TestListStarExpr;

FuncBodySuite: (stmt=SimpleStmt | stmt=Stmt)+;

Keyword: 'donnée' | 'nombre' | 'entier' | 'afficher' | 'montrer' |
    'la gamme' | 'followed by' | 'appeler' | 'fonction' | 'avec' | 'paramètre' |
    'paramètres' | 'set' | 'to' | 'la' | 'résultat' | 'de' | 'déclarer' |
    'passer' | 'casser' | 'continuer' | 'retourner'| 'définir' | 'faire' | 'fin' | 'as' |
    'si' | 'sinon' | 'autrement' | 'pour' | 'tant que' | 'plus' | 'moins' | 'et' |
    'ou' | 'pas' | 'inférieur' | 'supérieur' | 'égual' | 'different' | 'est' | 'dans' |
    'fois' | 'divisé' | 'par' | 'modulo' | 'à la puissance' | 'true' | 'false' | 'True'
    | 'False';
SafeId: !Keyword ID;
Name: id=SafeId;
String: value=STRING;
Number: value=NUMBER;
Boolean: value=BOOL;
NoneType: value='None';
